###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.41.0.51741/W32 for ARM     21/Feb/2012  16:06:29 #
# Copyright (C) 1999-2009 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊ #
#                    µÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\library\src\stm32f10x_flas #
#                    h.c                                                      #
#    Command line =  F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊ #
#                    µÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\library\src\stm32f10x_flas #
#                    h.c -lcN F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ #
#                    ËÍºÍ½ÓÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\Deb #
#                    ug\List\ -o F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµ #
#                    Ä·¢ËÍºÍ½ÓÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\ #
#                    Debug\Obj\ --no_cse --no_unroll --no_inline              #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Norma #
#                    l.h" -I F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢Ë #
#                    ÍºÍ½ÓÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\..\  #
#                    -I F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½Ó #
#                    ÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\..\..\lib #
#                    rary\inc\ -I "C:\Program Files\IAR Systems\Embedded      #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊ #
#                    µÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\Debug\List\s #
#                    tm32f10x_flash.lst                                       #
#    Object file  =  F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊ #
#                    µÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\Debug\Obj\st #
#                    m32f10x_flash.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\library\src\stm32f10x_flash.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_flash.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides all the FLASH firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_flash.h"
     18          
     19          /* Private typedef -----------------------------------------------------------*/
     20          /* Private define ------------------------------------------------------------*/
     21          /* Flash Access Control Register bits */
     22          #define ACR_LATENCY_Mask         ((u32)0x00000038)
     23          #define ACR_HLFCYA_Mask          ((u32)0xFFFFFFF7)
     24          #define ACR_PRFTBE_Mask          ((u32)0xFFFFFFEF)
     25          
     26          #ifdef _FLASH_PROG
     27          /* Flash Access Control Register bits */
     28          #define ACR_PRFTBS_Mask          ((u32)0x00000020) 
     29          
     30          /* Flash Control Register bits */
     31          #define CR_PG_Set                ((u32)0x00000001)
     32          #define CR_PG_Reset              ((u32)0x00001FFE) 
     33          
     34          #define CR_PER_Set               ((u32)0x00000002)
     35          #define CR_PER_Reset             ((u32)0x00001FFD)
     36          
     37          #define CR_MER_Set               ((u32)0x00000004)
     38          #define CR_MER_Reset             ((u32)0x00001FFB)
     39          
     40          #define CR_OPTPG_Set             ((u32)0x00000010)
     41          #define CR_OPTPG_Reset           ((u32)0x00001FEF)
     42          
     43          #define CR_OPTER_Set             ((u32)0x00000020)
     44          #define CR_OPTER_Reset           ((u32)0x00001FDF)
     45          
     46          #define CR_STRT_Set              ((u32)0x00000040)
     47          							 
     48          #define CR_LOCK_Set              ((u32)0x00000080)
     49          
     50          /* FLASH Mask */
     51          #define RDPRT_Mask               ((u32)0x00000002)
     52          #define WRP0_Mask                ((u32)0x000000FF)
     53          #define WRP1_Mask                ((u32)0x0000FF00)
     54          #define WRP2_Mask                ((u32)0x00FF0000)
     55          #define WRP3_Mask                ((u32)0xFF000000)
     56          
     57          /* FLASH Keys */
     58          #define RDP_Key                  ((u16)0x00A5)
     59          #define FLASH_KEY1               ((u32)0x45670123)
     60          #define FLASH_KEY2               ((u32)0xCDEF89AB)
     61          
     62          /* Delay definition */   
     63          #define EraseTimeout             ((u32)0x00000FFF)
     64          #define ProgramTimeout           ((u32)0x0000000F)
     65          #endif
     66          
     67          /* Private macro -------------------------------------------------------------*/
     68          /* Private variables ---------------------------------------------------------*/
     69          /* Private function prototypes -----------------------------------------------*/
     70          #ifdef _FLASH_PROG
     71          static void delay(void);
     72          #endif
     73          
     74          /* Private functions ---------------------------------------------------------*/
     75          /*******************************************************************************
     76          * Function Name  : FLASH_SetLatency
     77          * Description    : Sets the code latency value.
     78          * Input          : - FLASH_Latency: specifies the FLASH Latency value.
     79          *                    This parameter can be one of the following values:
     80          *                       - FLASH_Latency_0: FLASH Zero Latency cycle
     81          *                       - FLASH_Latency_1: FLASH One Latency cycle
     82          *                       - FLASH_Latency_2: FLASH Two Latency cycles
     83          * Output         : None
     84          * Return         : None
     85          *******************************************************************************/
     86          void FLASH_SetLatency(u32 FLASH_Latency)
     87          {
     88            /* Check the parameters */
     89            assert_param(IS_FLASH_LATENCY(FLASH_Latency));
     90            
     91            /* Sets the Latency value */
     92            FLASH->ACR &= ACR_LATENCY_Mask;
     93            FLASH->ACR |= FLASH_Latency;
     94          }
     95          
     96          /*******************************************************************************
     97          * Function Name  : FLASH_HalfCycleAccessCmd
     98          * Description    : Enables or disables the Half cycle flash access.
     99          * Input          : - FLASH_HalfCycle: specifies the FLASH Half cycle Access mode.
    100          *                    This parameter can be one of the following values:
    101          *                       - FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
    102          *                       - FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
    103          * Output         : None
    104          * Return         : None
    105          *******************************************************************************/
    106          void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)
    107          {
    108            /* Check the parameters */
    109            assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
    110            
    111            /* Enable or disable the Half cycle access */
    112            FLASH->ACR &= ACR_HLFCYA_Mask;
    113            FLASH->ACR |= FLASH_HalfCycleAccess;
    114          }
    115          
    116          /*******************************************************************************
    117          * Function Name  : FLASH_PrefetchBufferCmd
    118          * Description    : Enables or disables the Prefetch Buffer.
    119          * Input          : - FLASH_PrefetchBuffer: specifies the Prefetch buffer status.
    120          *                    This parameter can be one of the following values:
    121          *                       - FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
    122          *                       - FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
    123          * Output         : None
    124          * Return         : None
    125          *******************************************************************************/
    126          void FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer)
    127          {
    128            /* Check the parameters */
    129            assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
    130            
    131            /* Enable or disable the Prefetch Buffer */
    132            FLASH->ACR &= ACR_PRFTBE_Mask;
    133            FLASH->ACR |= FLASH_PrefetchBuffer;
    134          }
    135          
    136          #ifdef _FLASH_PROG
    137          /*******************************************************************************
    138          * Function Name  : FLASH_Unlock
    139          * Description    : Unlocks the FLASH Program Erase Controller.
    140          * Input          : None
    141          * Output         : None
    142          * Return         : None
    143          *******************************************************************************/
    144          void FLASH_Unlock(void)
    145          {
    146            /* Authorize the FPEC Access */
    147            FLASH->KEYR = FLASH_KEY1;
    148            FLASH->KEYR = FLASH_KEY2;
    149          }
    150          
    151          /*******************************************************************************
    152          * Function Name  : FLASH_Lock
    153          * Description    : Locks the FLASH Program Erase Controller.
    154          * Input          : None
    155          * Output         : None
    156          * Return         : None
    157          *******************************************************************************/
    158          void FLASH_Lock(void)
    159          {
    160            /* Set the Lock Bit to lock the FPEC and the FCR */
    161            FLASH->CR |= CR_LOCK_Set;
    162          }
    163          
    164          /*******************************************************************************
    165          * Function Name  : FLASH_ErasePage
    166          * Description    : Erases a specified FLASH page.
    167          * Input          : - Page_Address: The page address to be erased.
    168          * Output         : None
    169          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    170          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    171          *                  FLASH_TIMEOUT.
    172          *******************************************************************************/
    173          FLASH_Status FLASH_ErasePage(u32 Page_Address)
    174          {
    175            FLASH_Status status = FLASH_COMPLETE;
    176          
    177            /* Check the parameters */
    178            assert_param(IS_FLASH_ADDRESS(Page_Address));
    179          
    180            /* Wait for last operation to be completed */
    181            status = FLASH_WaitForLastOperation(EraseTimeout);
    182            
    183            if(status == FLASH_COMPLETE)
    184            { 
    185              /* if the previous operation is completed, proceed to erase the page */
    186              FLASH->CR|= CR_PER_Set;
    187              FLASH->AR = Page_Address; 
    188              FLASH->CR|= CR_STRT_Set;
    189              
    190              /* Wait for last operation to be completed */
    191              status = FLASH_WaitForLastOperation(EraseTimeout);
    192          
    193              if(status != FLASH_BUSY)
    194              {
    195                /* if the erase operation is completed, disable the PER Bit */
    196                FLASH->CR &= CR_PER_Reset;
    197              }
    198            }
    199            /* Return the Erase Status */
    200            return status;
    201          }
    202          
    203          /*******************************************************************************
    204          * Function Name  : FLASH_EraseAllPages
    205          * Description    : Erases all FLASH pages.
    206          * Input          : None
    207          * Output         : None
    208          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    209          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    210          *                  FLASH_TIMEOUT.
    211          *******************************************************************************/
    212          FLASH_Status FLASH_EraseAllPages(void)
    213          {
    214            FLASH_Status status = FLASH_COMPLETE;
    215          
    216            /* Wait for last operation to be completed */
    217            status = FLASH_WaitForLastOperation(EraseTimeout);
    218            
    219            if(status == FLASH_COMPLETE)
    220            {
    221              /* if the previous operation is completed, proceed to erase all pages */
    222               FLASH->CR |= CR_MER_Set;
    223               FLASH->CR |= CR_STRT_Set;
    224              
    225              /* Wait for last operation to be completed */
    226              status = FLASH_WaitForLastOperation(EraseTimeout);
    227          
    228              if(status != FLASH_BUSY)
    229              {
    230                /* if the erase operation is completed, disable the MER Bit */
    231                FLASH->CR &= CR_MER_Reset;
    232              }
    233            }	   
    234            /* Return the Erase Status */
    235            return status;
    236          }
    237          
    238          /*******************************************************************************
    239          * Function Name  : FLASH_EraseOptionBytes
    240          * Description    : Erases the FLASH option bytes.
    241          * Input          : None
    242          * Output         : None
    243          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    244          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    245          *                  FLASH_TIMEOUT.
    246          *******************************************************************************/
    247          FLASH_Status FLASH_EraseOptionBytes(void)
    248          {
    249            FLASH_Status status = FLASH_COMPLETE;
    250            
    251            /* Wait for last operation to be completed */
    252            status = FLASH_WaitForLastOperation(EraseTimeout);
    253          
    254            if(status == FLASH_COMPLETE)
    255            {
    256              /* Authorize the small information block programming */
    257              FLASH->OPTKEYR = FLASH_KEY1;
    258              FLASH->OPTKEYR = FLASH_KEY2;
    259              
    260              /* if the previous operation is completed, proceed to erase the option bytes */
    261              FLASH->CR |= CR_OPTER_Set;
    262              FLASH->CR |= CR_STRT_Set;
    263          
    264              /* Wait for last operation to be completed */
    265              status = FLASH_WaitForLastOperation(EraseTimeout);
    266              
    267              if(status == FLASH_COMPLETE)
    268              {
    269                /* if the erase operation is completed, disable the OPTER Bit */
    270                FLASH->CR &= CR_OPTER_Reset;
    271                 
    272                /* Enable the Option Bytes Programming operation */
    273                FLASH->CR |= CR_OPTPG_Set;
    274          
    275                /* Enable the readout access */
    276                OB->RDP= RDP_Key; 
    277          
    278                /* Wait for last operation to be completed */
    279                status = FLASH_WaitForLastOperation(ProgramTimeout);
    280           
    281                if(status != FLASH_BUSY)
    282                {
    283                  /* if the program operation is completed, disable the OPTPG Bit */
    284                  FLASH->CR &= CR_OPTPG_Reset;
    285                }
    286              }
    287              else
    288              {
    289                if (status != FLASH_BUSY)
    290                {
    291                  /* Disable the OPTPG Bit */
    292                  FLASH->CR &= CR_OPTPG_Reset;
    293                }
    294              }  
    295            }
    296            /* Return the erase status */
    297            return status;
    298          }
    299          
    300          /*******************************************************************************
    301          * Function Name  : FLASH_ProgramWord
    302          * Description    : Programs a word at a specified address.
    303          * Input          : - Address: specifies the address to be programmed.
    304          *                  - Data: specifies the data to be programmed.
    305          * Output         : None
    306          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    307          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    308          *                  FLASH_TIMEOUT. 
    309          *******************************************************************************/
    310          FLASH_Status FLASH_ProgramWord(u32 Address, u32 Data)
    311          {
    312            FLASH_Status status = FLASH_COMPLETE;
    313          
    314            /* Check the parameters */
    315            assert_param(IS_FLASH_ADDRESS(Address));
    316          
    317            /* Wait for last operation to be completed */
    318            status = FLASH_WaitForLastOperation(ProgramTimeout);
    319            
    320            if(status == FLASH_COMPLETE)
    321            {
    322              /* if the previous operation is completed, proceed to program the new first 
    323              half word */
    324              FLASH->CR |= CR_PG_Set;
    325            
    326              *(vu16*)Address = (u16)Data;
    327          
    328              /* Wait for last operation to be completed */
    329              status = FLASH_WaitForLastOperation(ProgramTimeout);
    330           
    331              if(status == FLASH_COMPLETE)
    332              {
    333                /* if the previous operation is completed, proceed to program the new second 
    334                half word */
    335                *(vu16*)(Address + 2) = Data >> 16;
    336              
    337                /* Wait for last operation to be completed */
    338                status = FLASH_WaitForLastOperation(ProgramTimeout);
    339                  
    340                if(status != FLASH_BUSY)
    341                {
    342                  /* Disable the PG Bit */
    343                  FLASH->CR &= CR_PG_Reset;
    344                }
    345              }
    346              else
    347              {
    348                if (status != FLASH_BUSY)
    349                {
    350                  /* Disable the PG Bit */
    351                  FLASH->CR &= CR_PG_Reset;
    352                }
    353               }
    354            }
    355            /* Return the Program Status */
    356            return status;
    357          }
    358          
    359          /*******************************************************************************
    360          * Function Name  : FLASH_ProgramHalfWord
    361          * Description    : Programs a half word at a specified address.
    362          * Input          : - Address: specifies the address to be programmed.
    363          *                  - Data: specifies the data to be programmed.
    364          * Output         : None
    365          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    366          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    367          *                  FLASH_TIMEOUT. 
    368          *******************************************************************************/
    369          FLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data)
    370          {
    371            FLASH_Status status = FLASH_COMPLETE;
    372          
    373            /* Check the parameters */
    374            assert_param(IS_FLASH_ADDRESS(Address));
    375          
    376            /* Wait for last operation to be completed */
    377            status = FLASH_WaitForLastOperation(ProgramTimeout);
    378            
    379            if(status == FLASH_COMPLETE)
    380            {
    381              /* if the previous operation is completed, proceed to program the new data */
    382              FLASH->CR |= CR_PG_Set;
    383            
    384              *(vu16*)Address = Data;
    385              /* Wait for last operation to be completed */
    386              status = FLASH_WaitForLastOperation(ProgramTimeout);
    387          
    388              if(status != FLASH_BUSY)
    389              {
    390                /* if the program operation is completed, disable the PG Bit */
    391                FLASH->CR &= CR_PG_Reset;
    392              }
    393            } 
    394            /* Return the Program Status */
    395            return status;
    396          }
    397          
    398          /*******************************************************************************
    399          * Function Name  : FLASH_ProgramOptionByteData
    400          * Description    : Programs a half word at a specified Option Byte Data address.
    401          * Input          : - Address: specifies the address to be programmed.
    402          *                    This parameter can be 0x1FFFF804 or 0x1FFFF806. 
    403          *                  - Data: specifies the data to be programmed.
    404          * Output         : None
    405          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    406          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    407          *                  FLASH_TIMEOUT. 
    408          *******************************************************************************/
    409          FLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data)
    410          {
    411            FLASH_Status status = FLASH_COMPLETE;
    412          
    413            /* Check the parameters */
    414            assert_param(IS_OB_DATA_ADDRESS(Address));
    415          
    416            status = FLASH_WaitForLastOperation(ProgramTimeout);
    417          
    418            if(status == FLASH_COMPLETE)
    419            {
    420              /* Authorize the small information block programming */
    421              FLASH->OPTKEYR = FLASH_KEY1;
    422              FLASH->OPTKEYR = FLASH_KEY2;
    423          
    424              /* Enables the Option Bytes Programming operation */
    425              FLASH->CR |= CR_OPTPG_Set; 
    426              *(vu16*)Address = Data;
    427              
    428              /* Wait for last operation to be completed */
    429              status = FLASH_WaitForLastOperation(ProgramTimeout);
    430          
    431              if(status != FLASH_BUSY)
    432              {
    433                /* if the program operation is completed, disable the OPTPG Bit */
    434                FLASH->CR &= CR_OPTPG_Reset;
    435              }
    436            }    
    437            /* Return the Option Byte Data Program Status */
    438            return status;      
    439          }
    440          
    441          /*******************************************************************************
    442          * Function Name  : FLASH_EnableWriteProtection
    443          * Description    : Write protects the desired pages
    444          * Input          : - FLASH_Pages: specifies the address of the pages to be 
    445          *                    write protected. This parameter can be:
    446          *                    - For STM32F10Xxx Medium-density devices (FLASH page size equal to 1 KB)
    447          *                       - A value between FLASH_WRProt_Pages0to3 and 
    448          *                         FLASH_WRProt_Pages124to127
    449          *                    - For STM32F10Xxx High-density devices (FLASH page size equal to 2 KB) 
    450          *                       - A value between FLASH_WRProt_Pages0to1 and
    451          *                         FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255 
    452          *                       - FLASH_WRProt_AllPages
    453          * Output         : None
    454          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    455          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    456          *                  FLASH_TIMEOUT.
    457          *******************************************************************************/
    458          FLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages)
    459          {
    460            u16 WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
    461            
    462            FLASH_Status status = FLASH_COMPLETE;
    463            
    464            /* Check the parameters */
    465            assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
    466            
    467            FLASH_Pages = (u32)(~FLASH_Pages);
    468            WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
    469            WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
    470            WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
    471            WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
    472            
    473            /* Wait for last operation to be completed */
    474            status = FLASH_WaitForLastOperation(ProgramTimeout);
    475            
    476            if(status == FLASH_COMPLETE)
    477            {
    478              /* Authorizes the small information block programming */
    479              FLASH->OPTKEYR = FLASH_KEY1;
    480              FLASH->OPTKEYR = FLASH_KEY2;
    481              FLASH->CR |= CR_OPTPG_Set;
    482          
    483              if(WRP0_Data != 0xFF)
    484              {
    485                OB->WRP0 = WRP0_Data;
    486                
    487                /* Wait for last operation to be completed */
    488                status = FLASH_WaitForLastOperation(ProgramTimeout);
    489              }
    490              if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
    491              {
    492                OB->WRP1 = WRP1_Data;
    493                
    494                /* Wait for last operation to be completed */
    495                status = FLASH_WaitForLastOperation(ProgramTimeout);
    496              }
    497          
    498              if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
    499              {
    500                OB->WRP2 = WRP2_Data;
    501                
    502                /* Wait for last operation to be completed */
    503                status = FLASH_WaitForLastOperation(ProgramTimeout);
    504              }
    505              
    506              if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
    507              {
    508                OB->WRP3 = WRP3_Data;
    509               
    510                /* Wait for last operation to be completed */
    511                status = FLASH_WaitForLastOperation(ProgramTimeout);
    512              }
    513                    
    514              if(status != FLASH_BUSY)
    515              {
    516                /* if the program operation is completed, disable the OPTPG Bit */
    517                FLASH->CR &= CR_OPTPG_Reset;
    518              }
    519            } 
    520            /* Return the write protection operation Status */
    521            return status;       
    522          }
    523          
    524          /*******************************************************************************
    525          * Function Name  : FLASH_ReadOutProtection
    526          * Description    : Enables or disables the read out protection.
    527          *                  If the user has already programmed the other option bytes before 
    528          *                  calling this function, he must re-program them since this 
    529          *                  function erases all option bytes.
    530          * Input          : - Newstate: new state of the ReadOut Protection.
    531          *                    This parameter can be: ENABLE or DISABLE.
    532          * Output         : None
    533          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    534          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    535          *                  FLASH_TIMEOUT.
    536          *******************************************************************************/
    537          FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
    538          {
    539            FLASH_Status status = FLASH_COMPLETE;
    540          
    541            /* Check the parameters */
    542            assert_param(IS_FUNCTIONAL_STATE(NewState));
    543          
    544            status = FLASH_WaitForLastOperation(EraseTimeout);
    545          
    546            if(status == FLASH_COMPLETE)
    547            {
    548              /* Authorizes the small information block programming */
    549              FLASH->OPTKEYR = FLASH_KEY1;
    550              FLASH->OPTKEYR = FLASH_KEY2;
    551          
    552              FLASH->CR |= CR_OPTER_Set;
    553              FLASH->CR |= CR_STRT_Set;
    554          
    555              /* Wait for last operation to be completed */
    556              status = FLASH_WaitForLastOperation(EraseTimeout);
    557          
    558              if(status == FLASH_COMPLETE)
    559              {
    560                /* if the erase operation is completed, disable the OPTER Bit */
    561                FLASH->CR &= CR_OPTER_Reset;
    562          
    563                /* Enable the Option Bytes Programming operation */
    564                FLASH->CR |= CR_OPTPG_Set; 
    565          
    566                if(NewState != DISABLE)
    567                {
    568                  OB->RDP = 0x00;
    569                }
    570                else
    571                {
    572                  OB->RDP = RDP_Key;  
    573                }
    574          
    575                /* Wait for last operation to be completed */
    576                status = FLASH_WaitForLastOperation(EraseTimeout); 
    577              
    578                if(status != FLASH_BUSY)
    579                {
    580                  /* if the program operation is completed, disable the OPTPG Bit */
    581                  FLASH->CR &= CR_OPTPG_Reset;
    582                }
    583              }
    584              else 
    585              {
    586                if(status != FLASH_BUSY)
    587                {
    588                  /* Disable the OPTER Bit */
    589                  FLASH->CR &= CR_OPTER_Reset;
    590                }
    591              }
    592            }
    593            /* Return the protection operation Status */
    594            return status;      
    595          }
    596            	
    597          /*******************************************************************************
    598          * Function Name  : FLASH_UserOptionByteConfig
    599          * Description    : Programs the FLASH User Option Byte: IWDG_SW / RST_STOP /
    600          *                  RST_STDBY.
    601          * Input          : - OB_IWDG: Selects the IWDG mode
    602          *                     This parameter can be one of the following values:
    603          *                     - OB_IWDG_SW: Software IWDG selected
    604          *                     - OB_IWDG_HW: Hardware IWDG selected
    605          *                  - OB_STOP: Reset event when entering STOP mode.
    606          *                     This parameter can be one of the following values:
    607          *                     - OB_STOP_NoRST: No reset generated when entering in STOP
    608          *                     - OB_STOP_RST: Reset generated when entering in STOP
    609          *                  - OB_STDBY: Reset event when entering Standby mode.
    610          *                    This parameter can be one of the following values:
    611          *                     - OB_STDBY_NoRST: No reset generated when entering in STANDBY
    612          *                     - OB_STDBY_RST: Reset generated when entering in STANDBY
    613          * Output         : None
    614          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    615          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    616          *                  FLASH_TIMEOUT.
    617          *******************************************************************************/
    618          FLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
    619          {
    620            FLASH_Status status = FLASH_COMPLETE; 
    621          
    622            /* Check the parameters */
    623            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
    624            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
    625            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
    626          
    627            /* Authorize the small information block programming */
    628            FLASH->OPTKEYR = FLASH_KEY1;
    629            FLASH->OPTKEYR = FLASH_KEY2;
    630            
    631            /* Wait for last operation to be completed */
    632            status = FLASH_WaitForLastOperation(ProgramTimeout);
    633            
    634            if(status == FLASH_COMPLETE)
    635            {  
    636              /* Enable the Option Bytes Programming operation */
    637              FLASH->CR |= CR_OPTPG_Set; 
    638                     
    639              OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
    640            
    641              /* Wait for last operation to be completed */
    642              status = FLASH_WaitForLastOperation(ProgramTimeout);
    643          
    644              if(status != FLASH_BUSY)
    645              {
    646                /* if the program operation is completed, disable the OPTPG Bit */
    647                FLASH->CR &= CR_OPTPG_Reset;
    648              }
    649            }    
    650            /* Return the Option Byte program Status */
    651            return status;
    652          }
    653          
    654          /*******************************************************************************
    655          * Function Name  : FLASH_GetUserOptionByte
    656          * Description    : Returns the FLASH User Option Bytes values.
    657          * Input          : None
    658          * Output         : None
    659          * Return         : The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
    660          *                  and RST_STDBY(Bit2).
    661          *******************************************************************************/
    662          u32 FLASH_GetUserOptionByte(void)
    663          {
    664            /* Return the User Option Byte */
    665            return (u32)(FLASH->OBR >> 2);
    666          }
    667          
    668          /*******************************************************************************
    669          * Function Name  : FLASH_GetWriteProtectionOptionByte
    670          * Description    : Returns the FLASH Write Protection Option Bytes Register value.
    671          * Input          : None
    672          * Output         : None
    673          * Return         : The FLASH Write Protection  Option Bytes Register value
    674          *******************************************************************************/
    675          u32 FLASH_GetWriteProtectionOptionByte(void)
    676          {
    677            /* Return the Falsh write protection Register value */
    678            return (u32)(FLASH->WRPR);
    679          }
    680          
    681          /*******************************************************************************
    682          * Function Name  : FLASH_GetReadOutProtectionStatus
    683          * Description    : Checks whether the FLASH Read Out Protection Status is set 
    684          *                  or not.
    685          * Input          : None
    686          * Output         : None
    687          * Return         : FLASH ReadOut Protection Status(SET or RESET)
    688          *******************************************************************************/
    689          FlagStatus FLASH_GetReadOutProtectionStatus(void)
    690          {
    691            FlagStatus readoutstatus = RESET;
    692          
    693            if ((FLASH->OBR & RDPRT_Mask) != (u32)RESET)
    694            {
    695              readoutstatus = SET;
    696            }
    697            else
    698            {
    699              readoutstatus = RESET;
    700            }
    701            return readoutstatus;
    702          }
    703          
    704          /*******************************************************************************
    705          * Function Name  : FLASH_GetPrefetchBufferStatus
    706          * Description    : Checks whether the FLASH Prefetch Buffer status is set or not.
    707          * Input          : None
    708          * Output         : None
    709          * Return         : FLASH Prefetch Buffer Status (SET or RESET).
    710          *******************************************************************************/
    711          FlagStatus FLASH_GetPrefetchBufferStatus(void)
    712          {
    713            FlagStatus bitstatus = RESET;
    714            
    715            if ((FLASH->ACR & ACR_PRFTBS_Mask) != (u32)RESET)
    716            {
    717              bitstatus = SET;
    718            }
    719            else
    720            {
    721              bitstatus = RESET;
    722            }
    723            /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
    724            return bitstatus; 
    725          }
    726          
    727          /*******************************************************************************
    728          * Function Name  : FLASH_ITConfig
    729          * Description    : Enables or disables the specified FLASH interrupts.
    730          * Input          : - FLASH_IT: specifies the FLASH interrupt sources to be 
    731          *                    enabled or disabled.
    732          *                    This parameter can be any combination of the following values:
    733          *                       - FLASH_IT_ERROR: FLASH Error Interrupt
    734          *                       - FLASH_IT_EOP: FLASH end of operation Interrupt
    735          * Output         : None
    736          * Return         : None 
    737          *******************************************************************************/
    738          void FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState)
    739          {
    740            /* Check the parameters */
    741            assert_param(IS_FLASH_IT(FLASH_IT)); 
    742            assert_param(IS_FUNCTIONAL_STATE(NewState));
    743          
    744            if(NewState != DISABLE)
    745            {
    746              /* Enable the interrupt sources */
    747              FLASH->CR |= FLASH_IT;
    748            }
    749            else
    750            {
    751              /* Disable the interrupt sources */
    752              FLASH->CR &= ~(u32)FLASH_IT;
    753            }
    754          }
    755          
    756          /*******************************************************************************
    757          * Function Name  : FLASH_GetFlagStatus
    758          * Description    : Checks whether the specified FLASH flag is set or not.
    759          * Input          : - FLASH_FLAG: specifies the FLASH flag to check.
    760          *                     This parameter can be one of the following values:
    761          *                    - FLASH_FLAG_BSY: FLASH Busy flag           
    762          *                    - FLASH_FLAG_PGERR: FLASH Program error flag       
    763          *                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    764          *                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
    765          *                    - FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
    766          * Output         : None
    767          * Return         : The new state of FLASH_FLAG (SET or RESET).
    768          *******************************************************************************/
    769          FlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG)
    770          {
    771            FlagStatus bitstatus = RESET;
    772          
    773            /* Check the parameters */
    774            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
    775          
    776            if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
    777            {
    778              if((FLASH->OBR & FLASH_FLAG_OPTERR) != (u32)RESET)
    779              {
    780                bitstatus = SET;
    781              }
    782              else
    783              {
    784                bitstatus = RESET;
    785              }
    786            }
    787            else
    788            {
    789             if((FLASH->SR & FLASH_FLAG) != (u32)RESET)
    790              {
    791                bitstatus = SET;
    792              }
    793              else
    794              {
    795                bitstatus = RESET;
    796              }
    797            }
    798            /* Return the new state of FLASH_FLAG (SET or RESET) */
    799            return bitstatus;
    800          }
    801          
    802          /*******************************************************************************
    803          * Function Name  : FLASH_ClearFlag
    804          * Description    : Clears the FLASH’s pending flags.
    805          * Input          : - FLASH_FLAG: specifies the FLASH flags to clear.
    806          *                    This parameter can be any combination of the following values:
    807          *                    - FLASH_FLAG_BSY: FLASH Busy flag           
    808          *                    - FLASH_FLAG_PGERR: FLASH Program error flag       
    809          *                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    810          *                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
    811          * Output         : None
    812          * Return         : None
    813          *******************************************************************************/
    814          void FLASH_ClearFlag(u16 FLASH_FLAG)
    815          {
    816            /* Check the parameters */
    817            assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
    818            
    819            /* Clear the flags */
    820            FLASH->SR = FLASH_FLAG;
    821          }
    822          
    823          /*******************************************************************************
    824          * Function Name  : FLASH_GetStatus
    825          * Description    : Returns the FLASH Status.
    826          * Input          : None
    827          * Output         : None
    828          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    829          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP or FLASH_COMPLETE
    830          *******************************************************************************/
    831          FLASH_Status FLASH_GetStatus(void)
    832          {
    833            FLASH_Status flashstatus = FLASH_COMPLETE;
    834            
    835            if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
    836            {
    837              flashstatus = FLASH_BUSY;
    838            }
    839            else 
    840            {  
    841              if(FLASH->SR & FLASH_FLAG_PGERR)
    842              { 
    843                flashstatus = FLASH_ERROR_PG;
    844              }
    845              else 
    846              {
    847                if(FLASH->SR & FLASH_FLAG_WRPRTERR)
    848                {
    849                  flashstatus = FLASH_ERROR_WRP;
    850                }
    851                else
    852                {
    853                  flashstatus = FLASH_COMPLETE;
    854                }
    855              }
    856            }
    857            /* Return the Flash Status */
    858            return flashstatus;
    859          }
    860          
    861          /*******************************************************************************
    862          * Function Name  : FLASH_WaitForLastOperation
    863          * Description    : Waits for a Flash operation to complete or a TIMEOUT to occur.
    864          * Input          : - Timeout: FLASH progamming Timeout
    865          * Output         : None
    866          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    867          *                  FLASH_ERROR_PG, FLASH_ERROR_WRP, FLASH_COMPLETE or 
    868          *                  FLASH_TIMEOUT.
    869          *******************************************************************************/
    870          FLASH_Status FLASH_WaitForLastOperation(u32 Timeout)
    871          { 
    872            FLASH_Status status = FLASH_COMPLETE;
    873             
    874            /* Check for the Flash Status */
    875            status = FLASH_GetStatus();
    876          
    877            /* Wait for a Flash operation to complete or a TIMEOUT to occur */
    878            while((status == FLASH_BUSY) && (Timeout != 0x00))
    879            {
    880              delay();
    881              status = FLASH_GetStatus();
    882              Timeout--;
    883            }
    884          
    885            if(Timeout == 0x00 )
    886            {
    887              status = FLASH_TIMEOUT;
    888            }
    889          
    890            /* Return the operation status */
    891            return status;
    892          }
    893          
    894          /*******************************************************************************
    895          * Function Name  : delay
    896          * Description    : Inserts a time delay.
    897          * Input          : None
    898          * Output         : None
    899          * Return         : None
    900          *******************************************************************************/
    901          static void delay(void)
    902          {
    903            vu32 i = 0;
    904          
    905            for(i = 0xFF; i != 0; i--)
    906            {
    907            }
    908          }
    909          #endif
    910          
    911          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     FLASH_HalfCycleAccessCmd      0
     FLASH_PrefetchBufferCmd       0
     FLASH_SetLatency              0


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     FLASH_SetLatency           24
     FLASH_HalfCycleAccessCmd   22
     FLASH_PrefetchBufferCmd    22
     ??DataTable2                4

 
 72 bytes in section .text
 
 72 bytes of CODE memory

Errors: none
Warnings: none
