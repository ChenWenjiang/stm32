###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.41.0.51741/W32 for ARM     21/Feb/2012  16:06:23 #
# Copyright (C) 1999-2009 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊ #
#                    µÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\library\src\stm32f10x_nvic #
#                    .c                                                       #
#    Command line =  F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊ #
#                    µÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\library\src\stm32f10x_nvic #
#                    .c -lcN F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢Ë #
#                    ÍºÍ½ÓÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\Debu #
#                    g\List\ -o F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ #
#                    ·¢ËÍºÍ½ÓÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 5.4\arm\INC\DLib_Config_Norma #
#                    l.h" -I F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢Ë #
#                    ÍºÍ½ÓÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\..\  #
#                    -I F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½Ó #
#                    ÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\..\..\lib #
#                    rary\inc\ -I "C:\Program Files\IAR Systems\Embedded      #
#                    Workbench 5.4\arm\INC\" -Ol                              #
#    List file    =  F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊ #
#                    µÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\Debug\List\s #
#                    tm32f10x_nvic.lst                                        #
#    Object file  =  F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊ #
#                    µÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\project\EWRAM\Debug\Obj\st #
#                    m32f10x_nvic.o                                           #
#                                                                             #
#                                                                             #
###############################################################################

F:\respir\STM32\¹Ì¼þ°ü¼°¿âº¯Êý\SOU\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé0\06.USARTµÄ·¢ËÍºÍ½ÓÊÕÊµÑé\library\src\stm32f10x_nvic.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_nvic.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides all the NVIC firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_nvic.h"
     18          
     19          /* Private typedef -----------------------------------------------------------*/
     20          /* Private define ------------------------------------------------------------*/
     21          #define AIRCR_VECTKEY_MASK    ((u32)0x05FA0000)
     22          
     23          /* Private macro -------------------------------------------------------------*/
     24          /* Private variables ---------------------------------------------------------*/
     25          /* Private function prototypes -----------------------------------------------*/
     26          /* Private functions ---------------------------------------------------------*/
     27          
     28          /*******************************************************************************
     29          * Function Name  : NVIC_DeInit
     30          * Description    : Deinitializes the NVIC peripheral registers to their default
     31          *                  reset values.
     32          * Input          : None
     33          * Output         : None
     34          * Return         : None
     35          *******************************************************************************/
     36          void NVIC_DeInit(void)
     37          {
     38            u32 index = 0;
     39            
     40            NVIC->ICER[0] = 0xFFFFFFFF;
     41            NVIC->ICER[1] = 0x0FFFFFFF;
     42            NVIC->ICPR[0] = 0xFFFFFFFF;
     43            NVIC->ICPR[1] = 0x0FFFFFFF;
     44            
     45            for(index = 0; index < 0x0F; index++)
     46            {
     47               NVIC->IPR[index] = 0x00000000;
     48            } 
     49          }
     50          
     51          /*******************************************************************************
     52          * Function Name  : NVIC_SCBDeInit
     53          * Description    : Deinitializes the SCB peripheral registers to their default 
     54          *                  reset values.
     55          * Input          : None
     56          * Output         : None
     57          * Return         : None
     58          *******************************************************************************/
     59          void NVIC_SCBDeInit(void)
     60          {
     61            u32 index = 0x00;
     62            
     63            SCB->ICSR = 0x0A000000;
     64            SCB->VTOR = 0x00000000;
     65            SCB->AIRCR = AIRCR_VECTKEY_MASK;
     66            SCB->SCR = 0x00000000;
     67            SCB->CCR = 0x00000000;
     68            for(index = 0; index < 0x03; index++)
     69            {
     70               SCB->SHPR[index] = 0;
     71            }
     72            SCB->SHCSR = 0x00000000;
     73            SCB->CFSR = 0xFFFFFFFF;
     74            SCB->HFSR = 0xFFFFFFFF;
     75            SCB->DFSR = 0xFFFFFFFF;
     76          }
     77          
     78          /*******************************************************************************
     79          * Function Name  : NVIC_PriorityGroupConfig
     80          * Description    : Configures the priority grouping: pre-emption priority
     81          *                  and subpriority.
     82          * Input          : - NVIC_PriorityGroup: specifies the priority grouping bits
     83          *                    length. This parameter can be one of the following values:
     84          *                       - NVIC_PriorityGroup_0: 0 bits for pre-emption priority
     85          *                         4 bits for subpriority
     86          *                       - NVIC_PriorityGroup_1: 1 bits for pre-emption priority
     87          *                         3 bits for subpriority
     88          *                       - NVIC_PriorityGroup_2: 2 bits for pre-emption priority
     89          *                         2 bits for subpriority
     90          *                       - NVIC_PriorityGroup_3: 3 bits for pre-emption priority
     91          *                         1 bits for subpriority
     92          *                       - NVIC_PriorityGroup_4: 4 bits for pre-emption priority
     93          *                         0 bits for subpriority
     94          * Output         : None
     95          * Return         : None
     96          *******************************************************************************/
     97          void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
     98          {
     99            /* Check the parameters */
    100            assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
    101            
    102            /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
    103            SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
    104          }
    105          
    106          /*******************************************************************************
    107          * Function Name  : NVIC_Init
    108          * Description    : Initializes the NVIC peripheral according to the specified
    109          *                  parameters in the NVIC_InitStruct.
    110          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
    111          *                    that contains the configuration information for the
    112          *                    specified NVIC peripheral.
    113          * Output         : None
    114          * Return         : None
    115          *******************************************************************************/
    116          void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
    117          {
    118            u32 tmppriority = 0x00, tmpreg = 0x00, tmpmask = 0x00;
    119            u32 tmppre = 0, tmpsub = 0x0F;
    120          
    121            /* Check the parameters */
    122            assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
    123            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
    124            assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
    125            assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    126              
    127            if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
    128            {
    129              /* Compute the Corresponding IRQ Priority --------------------------------*/    
    130              tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    131              tmppre = (0x4 - tmppriority);
    132              tmpsub = tmpsub >> tmppriority;
    133              
    134              tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    135              tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    136          
    137              tmppriority = tmppriority << 0x04;
    138              tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    139              
    140              tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    141              tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    142              tmpreg &= ~tmpmask;
    143              tmppriority &= tmpmask;  
    144              tmpreg |= tmppriority;
    145          
    146              NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    147              
    148              /* Enable the Selected IRQ Channels --------------------------------------*/
    149              NVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    150                (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    151            }
    152            else
    153            {
    154              /* Disable the Selected IRQ Channels -------------------------------------*/
    155              NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    156                (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    157            }
    158          }
    159          
    160          /*******************************************************************************
    161          * Function Name  : NVIC_StructInit
    162          * Description    : Fills each NVIC_InitStruct member with its default value.
    163          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
    164          *                    will be initialized.
    165          * Output         : None
    166          * Return         : None
    167          *******************************************************************************/
    168          void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
    169          {
    170            /* NVIC_InitStruct members default value */
    171            NVIC_InitStruct->NVIC_IRQChannel = 0x00;
    172            NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
    173            NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
    174            NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
    175          }
    176          
    177          /*******************************************************************************
    178          * Function Name  : NVIC_SETPRIMASK
    179          * Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
    180          * Input          : None
    181          * Output         : None
    182          * Return         : None
    183          *******************************************************************************/
    184          void NVIC_SETPRIMASK(void)
    185          {
    186            __SETPRIMASK();
    187          }
    188          
    189          /*******************************************************************************
    190          * Function Name  : NVIC_RESETPRIMASK
    191          * Description    : Disables the PRIMASK priority.
    192          * Input          : None
    193          * Output         : None
    194          * Return         : None
    195          *******************************************************************************/
    196          void NVIC_RESETPRIMASK(void)
    197          {
    198            __RESETPRIMASK();
    199          }
    200          
    201          /*******************************************************************************
    202          * Function Name  : NVIC_SETFAULTMASK
    203          * Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
    204          * Input          : None
    205          * Output         : None
    206          * Return         : None
    207          *******************************************************************************/
    208          void NVIC_SETFAULTMASK(void)
    209          {
    210            __SETFAULTMASK();
    211          }
    212          
    213          /*******************************************************************************
    214          * Function Name  : NVIC_RESETFAULTMASK
    215          * Description    : Disables the FAULTMASK priority.
    216          * Input          : None
    217          * Output         : None
    218          * Return         : None
    219          *******************************************************************************/
    220          void NVIC_RESETFAULTMASK(void)
    221          {
    222            __RESETFAULTMASK();
    223          }
    224          
    225          /*******************************************************************************
    226          * Function Name  : NVIC_BASEPRICONFIG
    227          * Description    : The execution priority can be changed from 15 (lowest 
    228                             configurable priority) to 1. Writing a zero  value will disable 
    229          *                  the mask of execution priority.
    230          * Input          : None
    231          * Output         : None
    232          * Return         : None
    233          *******************************************************************************/
    234          void NVIC_BASEPRICONFIG(u32 NewPriority)
    235          {
    236            /* Check the parameters */
    237            assert_param(IS_NVIC_BASE_PRI(NewPriority));
    238            
    239            __BASEPRICONFIG(NewPriority << 0x04);
    240          }
    241          
    242          /*******************************************************************************
    243          * Function Name  : NVIC_GetBASEPRI
    244          * Description    : Returns the BASEPRI mask value.
    245          * Input          : None
    246          * Output         : None
    247          * Return         : BASEPRI register value
    248          *******************************************************************************/
    249          u32 NVIC_GetBASEPRI(void)
    250          {
    251            return (__GetBASEPRI());
    252          }
    253          
    254          /*******************************************************************************
    255          * Function Name  : NVIC_GetCurrentPendingIRQChannel
    256          * Description    : Returns the current pending IRQ channel identifier.
    257          * Input          : None
    258          * Output         : None
    259          * Return         : Pending IRQ Channel Identifier.
    260          *******************************************************************************/
    261          u16 NVIC_GetCurrentPendingIRQChannel(void)
    262          {
    263            return ((u16)((SCB->ICSR & (u32)0x003FF000) >> 0x0C));
    264          }
    265          
    266          /*******************************************************************************
    267          * Function Name  : NVIC_GetIRQChannelPendingBitStatus
    268          * Description    : Checks whether the specified IRQ Channel pending bit is set
    269          *                  or not.
    270          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
    271          * Output         : None
    272          * Return         : The new state of IRQ Channel pending bit(SET or RESET).
    273          *******************************************************************************/
    274          ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
    275          {
    276            ITStatus pendingirqstatus = RESET;
    277            u32 tmp = 0x00;
    278            
    279            /* Check the parameters */
    280            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    281            
    282            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
    283          
    284            if (((NVIC->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
    285            {
    286              pendingirqstatus = SET;
    287            }
    288            else
    289            {
    290              pendingirqstatus = RESET;
    291            }
    292            return pendingirqstatus;
    293          }
    294          
    295          /*******************************************************************************
    296          * Function Name  : NVIC_SetIRQChannelPendingBit
    297          * Description    : Sets the NVICs interrupt pending bit.
    298          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
    299          * Output         : None
    300          * Return         : None
    301          *******************************************************************************/
    302          void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
    303          {
    304            /* Check the parameters */
    305            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    306            
    307            *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
    308          }
    309          
    310          /*******************************************************************************
    311          * Function Name  : NVIC_ClearIRQChannelPendingBit
    312          * Description    : Clears the NVICs interrupt pending bit.
    313          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
    314          * Output         : None
    315          * Return         : None
    316          *******************************************************************************/
    317          void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
    318          {
    319            /* Check the parameters */
    320            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    321            
    322            NVIC->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
    323          }
    324          
    325          /*******************************************************************************
    326          * Function Name  : NVIC_GetCurrentActiveHandler
    327          * Description    : Returns the current active Handler (IRQ Channel and
    328          *                  SystemHandler) identifier.
    329          * Input          : None
    330          * Output         : None
    331          * Return         : Active Handler Identifier.
    332          *******************************************************************************/
    333          u16 NVIC_GetCurrentActiveHandler(void)
    334          {
    335            return ((u16)(SCB->ICSR & (u32)0x3FF));
    336          }
    337          
    338          /*******************************************************************************
    339          * Function Name  : NVIC_GetIRQChannelActiveBitStatus
    340          * Description    : Checks whether the specified IRQ Channel active bit is set
    341          *                  or not.
    342          * Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
    343          * Output         : None
    344          * Return         : The new state of IRQ Channel active bit(SET or RESET).
    345          *******************************************************************************/
    346          ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
    347          {
    348            ITStatus activeirqstatus = RESET;
    349            u32 tmp = 0x00;
    350          
    351            /* Check the parameters */
    352            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    353            
    354            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
    355          
    356            if (((NVIC->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
    357            {
    358              activeirqstatus = SET;
    359            }
    360            else
    361            {
    362              activeirqstatus = RESET;
    363            }
    364            return activeirqstatus;
    365          }
    366          
    367          /*******************************************************************************
    368          * Function Name  : NVIC_GetCPUID
    369          * Description    : Returns the ID number, the version number and the implementation
    370          *                  details of the Cortex-M3 core.
    371          * Input          : None
    372          * Output         : None
    373          * Return         : CPU ID.
    374          *******************************************************************************/
    375          u32 NVIC_GetCPUID(void)
    376          {
    377            return (SCB->CPUID);
    378          }
    379          
    380          /*******************************************************************************
    381          * Function Name  : NVIC_SetVectorTable
    382          * Description    : Sets the vector table location and Offset.
    383          * Input          : - NVIC_VectTab: specifies if the vector table is in RAM or
    384          *                    FLASH memory.
    385          *                    This parameter can be one of the following values:
    386          *                       - NVIC_VectTab_RAM
    387          *                       - NVIC_VectTab_FLASH
    388          *                  - Offset: Vector Table base offset field. 
    389          *                            This value must be a multiple of 0x100.
    390          * Output         : None
    391          * Return         : None
    392          *******************************************************************************/
    393          void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
    394          { 
    395            /* Check the parameters */
    396            assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
    397            assert_param(IS_NVIC_OFFSET(Offset));  
    398             
    399            SCB->VTOR = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
    400          }
    401          
    402          /*******************************************************************************
    403          * Function Name  : NVIC_GenerateSystemReset
    404          * Description    : Generates a system reset.
    405          * Input          : None
    406          * Output         : None
    407          * Return         : None
    408          *******************************************************************************/
    409          void NVIC_GenerateSystemReset(void)
    410          {
    411            SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
    412          }
    413          
    414          /*******************************************************************************
    415          * Function Name  : NVIC_GenerateCoreReset
    416          * Description    : Generates a Core (Core + NVIC) reset.
    417          * Input          : None
    418          * Output         : None
    419          * Return         : None
    420          *******************************************************************************/
    421          void NVIC_GenerateCoreReset(void)
    422          {
    423            SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
    424          }
    425          
    426          /*******************************************************************************
    427          * Function Name  : NVIC_SystemLPConfig
    428          * Description    : Selects the condition for the system to enter low power mode.
    429          * Input          : - LowPowerMode: Specifies the new mode for the system to enter
    430          *                    low power mode.
    431          *                    This parameter can be one of the following values:
    432          *                       - NVIC_LP_SEVONPEND
    433          *                       - NVIC_LP_SLEEPDEEP
    434          *                       - NVIC_LP_SLEEPONEXIT
    435          *                  - NewState: new state of LP condition.
    436          *                    This parameter can be: ENABLE or DISABLE.
    437          * Output         : None
    438          * Return         : None
    439          *******************************************************************************/
    440          void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)
    441          {
    442            /* Check the parameters */
    443            assert_param(IS_NVIC_LP(LowPowerMode));
    444            assert_param(IS_FUNCTIONAL_STATE(NewState));  
    445            
    446            if (NewState != DISABLE)
    447            {
    448              SCB->SCR |= LowPowerMode;
    449            }
    450            else
    451            {
    452              SCB->SCR &= (u32)(~(u32)LowPowerMode);
    453            }
    454          }
    455          
    456          /*******************************************************************************
    457          * Function Name  : NVIC_SystemHandlerConfig
    458          * Description    : Enables or disables the specified System Handlers.
    459          * Input          : - SystemHandler: specifies the system handler to be enabled
    460          *                    or disabled.
    461          *                    This parameter can be one of the following values:
    462          *                       - SystemHandler_MemoryManage
    463          *                       - SystemHandler_BusFault
    464          *                       - SystemHandler_UsageFault
    465          *                  - NewState: new state of  specified System Handlers.
    466          *                    This parameter can be: ENABLE or DISABLE.
    467          * Output         : None
    468          * Return         : None
    469          *******************************************************************************/
    470          void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)
    471          {
    472            u32 tmpreg = 0x00;
    473          
    474            /* Check the parameters */
    475            assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
    476            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    477            
    478            tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
    479          
    480            if (NewState != DISABLE)
    481            {
    482              SCB->SHCSR |= tmpreg;
    483            }
    484            else
    485            {
    486              SCB->SHCSR &= ~tmpreg;
    487            }
    488          }
    489          
    490          /*******************************************************************************
    491          * Function Name  : NVIC_SystemHandlerPriorityConfig
    492          * Description    : Configures the specified System Handlers priority.
    493          * Input          : - SystemHandler: specifies the system handler to be
    494          *                    enabled or disabled.
    495          *                    This parameter can be one of the following values:
    496          *                       - SystemHandler_MemoryManage
    497          *                       - SystemHandler_BusFault
    498          *                       - SystemHandler_UsageFault
    499          *                       - SystemHandler_SVCall
    500          *                       - SystemHandler_DebugMonitor
    501          *                       - SystemHandler_PSV
    502          *                       - SystemHandler_SysTick
    503          *                  - SystemHandlerPreemptionPriority: new priority group of the
    504          *                    specified system handlers.
    505          *                  - SystemHandlerSubPriority: new sub priority of the specified
    506          *                    system handlers.
    507          * Output         : None
    508          * Return         : None
    509          *******************************************************************************/
    510          void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
    511                                                u8 SystemHandlerSubPriority)
    512          {
    513            u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
    514            u32 tmppriority = 0x00;
    515          
    516            /* Check the parameters */
    517            assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
    518            assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
    519            assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    520              
    521            tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
    522            tmp1 = (0x4 - tmppriority);
    523            tmp2 = tmp2 >> tmppriority;
    524              
    525            tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
    526            tmppriority |=  SystemHandlerSubPriority & tmp2;
    527          
    528            tmppriority = tmppriority << 0x04;
    529            tmp1 = SystemHandler & (u32)0xC0;
    530            tmp1 = tmp1 >> 0x06; 
    531            tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
    532            tmppriority = tmppriority << (tmp2 * 0x08);
    533            handlermask = (u32)0xFF << (tmp2 * 0x08);
    534            
    535            SCB->SHPR[tmp1] &= ~handlermask;
    536            SCB->SHPR[tmp1] |= tmppriority;
    537          }
    538          
    539          /*******************************************************************************
    540          * Function Name  : NVIC_GetSystemHandlerPendingBitStatus
    541          * Description    : Checks whether the specified System handlers pending bit is
    542          *                  set or not.
    543          * Input          : - SystemHandler: specifies the system handler pending bit to
    544          *                    check.
    545          *                    This parameter can be one of the following values:
    546          *                       - SystemHandler_MemoryManage
    547          *                       - SystemHandler_BusFault
    548          *                       - SystemHandler_SVCall
    549          * Output         : None
    550          * Return         : The new state of System Handler pending bit(SET or RESET).
    551          *******************************************************************************/
    552          ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
    553          {
    554            ITStatus bitstatus  = RESET;
    555            u32 tmp = 0x00, tmppos = 0x00;
    556          
    557            /* Check the parameters */
    558            assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
    559            
    560            tmppos = (SystemHandler >> 0x0A);
    561            tmppos &= (u32)0x0F;
    562          
    563            tmppos = (u32)0x01 << tmppos;
    564          
    565            tmp = SCB->SHCSR & tmppos;
    566          
    567            if (tmp == tmppos)
    568            {
    569              bitstatus = SET;
    570            }
    571            else
    572            {
    573              bitstatus = RESET;
    574            }
    575            return bitstatus;
    576          }
    577          
    578          /*******************************************************************************
    579          * Function Name  : NVIC_SetSystemHandlerPendingBit
    580          * Description    : Sets System Handler pending bit.
    581          * Input          : - SystemHandler: specifies the system handler pending bit
    582          *                    to be set.
    583          *                    This parameter can be one of the following values:
    584          *                       - SystemHandler_NMI
    585          *                       - SystemHandler_PSV
    586          *                       - SystemHandler_SysTick
    587          * Output         : None
    588          * Return         : None
    589          *******************************************************************************/
    590          void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
    591          {
    592            u32 tmp = 0x00;
    593          
    594            /* Check the parameters */
    595            assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
    596            
    597            /* Get the System Handler pending bit position */
    598            tmp = SystemHandler & (u32)0x1F;
    599            /* Set the corresponding System Handler pending bit */
    600            SCB->ICSR |= ((u32)0x01 << tmp);
    601          }
    602          
    603          /*******************************************************************************
    604          * Function Name  : NVIC_ClearSystemHandlerPendingBit
    605          * Description    : Clears System Handler pending bit.
    606          * Input          : - SystemHandler: specifies the system handler pending bit to
    607          *                    be clear.
    608          *                    This parameter can be one of the following values:
    609          *                       - SystemHandler_PSV
    610          *                       - SystemHandler_SysTick
    611          * Output         : None
    612          * Return         : None
    613          *******************************************************************************/
    614          void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
    615          {
    616            u32 tmp = 0x00;
    617          
    618            /* Check the parameters */
    619            assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
    620            
    621            /* Get the System Handler pending bit position */
    622            tmp = SystemHandler & (u32)0x1F;
    623            /* Clear the corresponding System Handler pending bit */
    624            SCB->ICSR |= ((u32)0x01 << (tmp - 0x01));
    625          }
    626          
    627          /*******************************************************************************
    628          * Function Name  : NVIC_GetSystemHandlerActiveBitStatus
    629          * Description    : Checks whether the specified System handlers active bit is
    630          *                  set or not.
    631          * Input          : - SystemHandler: specifies the system handler active bit to
    632          *                    check.
    633          *                    This parameter can be one of the following values:
    634          *                       - SystemHandler_MemoryManage
    635          *                       - SystemHandler_BusFault
    636          *                       - SystemHandler_UsageFault
    637          *                       - SystemHandler_SVCall
    638          *                       - SystemHandler_DebugMonitor
    639          *                       - SystemHandler_PSV
    640          *                       - SystemHandler_SysTick
    641          * Output         : None
    642          * Return         : The new state of System Handler active bit(SET or RESET).
    643          *******************************************************************************/
    644          ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
    645          {
    646            ITStatus bitstatus  = RESET;
    647          
    648            u32 tmp = 0x00, tmppos = 0x00;
    649          
    650            /* Check the parameters */
    651            assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
    652            
    653            tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;
    654          
    655            tmppos = (u32)0x01 << tmppos;
    656          
    657            tmp = SCB->SHCSR & tmppos;
    658          
    659            if (tmp == tmppos)
    660            {
    661              bitstatus = SET;
    662            }
    663            else
    664            {
    665              bitstatus = RESET;
    666            }
    667            return bitstatus;
    668          }
    669          
    670          /*******************************************************************************
    671          * Function Name  : NVIC_GetFaultHandlerSources
    672          * Description    : Returns the system fault handlers sources.
    673          * Input          : - SystemHandler: specifies the system handler to get its fault
    674          *                    sources.
    675          *                    This parameter can be one of the following values:
    676          *                       - SystemHandler_HardFault
    677          *                       - SystemHandler_MemoryManage
    678          *                       - SystemHandler_BusFault
    679          *                       - SystemHandler_UsageFault
    680          *                       - SystemHandler_DebugMonitor
    681          * Output         : None
    682          * Return         : Source of the fault handler.
    683          *******************************************************************************/
    684          u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
    685          {
    686            u32 faultsources = 0x00;
    687            u32 tmpreg = 0x00, tmppos = 0x00;
    688          
    689            /* Check the parameters */
    690            assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
    691            
    692            tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
    693            tmppos = (SystemHandler >> 0x14) & (u32)0x03;
    694          
    695            if (tmpreg == 0x00)
    696            {
    697              faultsources = SCB->HFSR;
    698            }
    699            else if (tmpreg == 0x01)
    700            {
    701              faultsources = SCB->CFSR >> (tmppos * 0x08);
    702              if (tmppos != 0x02)
    703              {
    704                faultsources &= (u32)0x0F;
    705              }
    706              else
    707              {
    708                faultsources &= (u32)0xFF;
    709              }
    710            }
    711            else
    712            {
    713              faultsources = SCB->DFSR;
    714            }
    715            return faultsources;
    716          }
    717          
    718          /*******************************************************************************
    719          * Function Name  : NVIC_GetFaultAddress
    720          * Description    : Returns the address of the location that generated a fault
    721          *                  handler.
    722          * Input          : - SystemHandler: specifies the system handler to get its
    723          *                    fault address.
    724          *                    This parameter can be one of the following values:
    725          *                       - SystemHandler_MemoryManage
    726          *                       - SystemHandler_BusFault
    727          * Output         : None
    728          * Return         : Fault address.
    729          *******************************************************************************/
    730          u32 NVIC_GetFaultAddress(u32 SystemHandler)
    731          {
    732            u32 faultaddress = 0x00;
    733            u32 tmp = 0x00;
    734          
    735            /* Check the parameters */
    736            assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
    737            
    738            tmp = (SystemHandler >> 0x16) & (u32)0x01;
    739          
    740            if (tmp == 0x00)
    741            {
    742              faultaddress = SCB->MMFAR;
    743            }
    744            else
    745            {
    746              faultaddress = SCB->BFAR;
    747            }
    748            return faultaddress;
    749          }
    750          
    751          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     NVIC_BASEPRICONFIG                  8
     NVIC_ClearIRQChannelPendingBit      0
     NVIC_ClearSystemHandlerPendingBit
                                         0
     NVIC_DeInit                         0
     NVIC_GenerateCoreReset              0
     NVIC_GenerateSystemReset            0
     NVIC_GetBASEPRI                     8
     NVIC_GetCPUID                       0
     NVIC_GetCurrentActiveHandler        0
     NVIC_GetCurrentPendingIRQChannel
                                         0
     NVIC_GetFaultAddress                0
     NVIC_GetFaultHandlerSources         4
     NVIC_GetIRQChannelActiveBitStatus
                                         4
     NVIC_GetIRQChannelPendingBitStatus
                                         4
     NVIC_GetSystemHandlerActiveBitStatus
                                         0
     NVIC_GetSystemHandlerPendingBitStatus
                                         0
     NVIC_Init                          12
     NVIC_PriorityGroupConfig            0
     NVIC_RESETFAULTMASK                 8
     NVIC_RESETPRIMASK                   8
     NVIC_SCBDeInit                      0
     NVIC_SETFAULTMASK                   8
     NVIC_SETPRIMASK                     8
     NVIC_SetIRQChannelPendingBit        0
     NVIC_SetSystemHandlerPendingBit
                                         0
     NVIC_SetVectorTable                 0
     NVIC_StructInit                     0
     NVIC_SystemHandlerConfig            0
     NVIC_SystemHandlerPriorityConfig
                                        16
     NVIC_SystemLPConfig                 0


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     NVIC_DeInit                      66
     NVIC_SCBDeInit                  108
     NVIC_PriorityGroupConfig         14
     NVIC_Init                       152
     NVIC_StructInit                  18
     NVIC_SETPRIMASK                   8
     NVIC_RESETPRIMASK                 8
     NVIC_SETFAULTMASK                 8
     NVIC_RESETFAULTMASK               8
     NVIC_BASEPRICONFIG               10
     NVIC_GetBASEPRI                   8
     NVIC_GetCurrentPendingIRQChannel
                                      12
     NVIC_GetIRQChannelPendingBitStatus
                                      46
     NVIC_SetIRQChannelPendingBit      8
     NVIC_ClearIRQChannelPendingBit   22
     NVIC_GetCurrentActiveHandler     10
     NVIC_GetIRQChannelActiveBitStatus
                                      46
     NVIC_GetCPUID                     6
     NVIC_SetVectorTable              12
     NVIC_GenerateSystemReset          8
     NVIC_GenerateCoreReset            8
     NVIC_SystemLPConfig              36
     NVIC_SystemHandlerConfig         44
     NVIC_SystemHandlerPriorityConfig
                                     110
     NVIC_GetSystemHandlerPendingBitStatus
                                      44
     NVIC_SetSystemHandlerPendingBit
                                      26
     NVIC_ClearSystemHandlerPendingBit
                                      28
     NVIC_GetSystemHandlerActiveBitStatus
                                      42
     NVIC_GetFaultHandlerSources      72
     NVIC_GetFaultAddress             28
     ??DataTable22                     4
     ??DataTable22_1                   4
     ??DataTable22_2                   4
     ??DataTable22_3                   4
     ??DataTable22_4                   4
     ??DataTable22_5                   4
     ??DataTable22_6                   4
     ??DataTable22_7                   4
     ??DataTable22_8                   4
     ??DataTable22_9                   4
     ??DataTable22_10                  4
     ??DataTable22_11                  4
     ??DataTable22_12                  4
     ??DataTable22_13                  4
     ??DataTable22_14                  4
     ??DataTable22_15                  4
     ??DataTable22_16                  4
     ??DataTable22_17                  4
     ??DataTable22_18                  4
     ??DataTable22_19                  4
     ??DataTable22_20                  4
     ??DataTable22_21                  4
     ??DataTable22_22                  4
     ??DataTable22_23                  4
     ??DataTable22_24                  4
     ??DataTable22_25                  4

 
 1 120 bytes in section .text
 
 1 120 bytes of CODE memory

Errors: none
Warnings: none
